<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zz-g&#39; blog</title>
  
  <subtitle>一个努力搬砖的非cs学生</subtitle>
  <link href="http://gzz20020424.github.io/atom.xml" rel="self"/>
  
  <link href="http://gzz20020424.github.io/"/>
  <updated>2022-05-11T13:23:35.397Z</updated>
  <id>http://gzz20020424.github.io/</id>
  
  <author>
    <name>甘展志</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链路层和局域网</title>
    <link href="http://gzz20020424.github.io/2022/05/11/lian-lu-ceng-he-ju-yu-wang/"/>
    <id>http://gzz20020424.github.io/2022/05/11/lian-lu-ceng-he-ju-yu-wang/</id>
    <published>2022-05-11T03:20:35.000Z</published>
    <updated>2022-05-11T13:23:35.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h1><p>本文基于中科大计算机网络自顶向下课程主要记录我在学习链路层和局域网过程中不理解及易混淆的知识点</p><hr><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><h3 id="重要概念："><a href="#重要概念：" class="headerlink" title="重要概念："></a>重要概念：</h3><ul><li>节点</li><li>链路</li><li>链路层帧<h3 id="不同层次解决的功能："><a href="#不同层次解决的功能：" class="headerlink" title="不同层次解决的功能："></a>不同层次解决的功能：</h3></li><li>链路层：一个节点传到另外一个节点的功能；回顾<strong>节点</strong>的概念：主机，路由器，交换机和WiFi接入点。</li><li>网络层：<strong>端到端传输</strong>的功能</li><li>传输层：<strong>进程到进程</strong>的区分，并实现协议使不可靠传输变成<strong>可靠传输</strong>。</li><li>应用层：交换报文实现<strong>网络应用</strong></li></ul><h3 id="链路层和网络层关联"><a href="#链路层和网络层关联" class="headerlink" title="链路层和网络层关联"></a>链路层和网络层关联</h3><p>旅行社（网络层中路由选择协议）为游客（数据报）制定了运输方式（链路层协议），走不同运输区段（链路）。该游客坐在不同交通工具中，被（封装）在不同的帧中。</p><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511152556.png"></p><hr><p>链路层服务（拓展）：</p><ul><li>流量控制：发送和接收方节点速率匹配</li><li>错误检测：<ul><li>由信号噪声和衰减引起</li><li>接收方检测出的错误：通知发送方重传</li><li>差错纠正：接收端检查纠正bit错误，不要重传</li><li>半双工和全双工</li></ul></li></ul><h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p>在<strong>网络适配器</strong>实现的，也称<strong>网络接口卡</strong>。<br><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511152638.png"><br>位于网络适配器核心的是<strong>链路层控制器</strong>，通常是一个实现了许多链路层服务的专用芯片。</p><h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><p><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511201728.png"><br>使用<strong>检测和纠正比特（EDC)<strong>来增强数据D，要保护的数据包括</strong>网络层传递下来需要通过链路传输的数据报</strong>和<strong>链路帧首部中的寻址信息，序号和其他字段</strong><br>只能检测出是否出现差错，有可能由<strong>未检出比特差错</strong>。一般差错检测技术越复杂，开销越大，应找到二者平衡。<br>以下三种检测差错技术：<strong>奇偶校验（基本思想），检验和方法（多用于运输层），循环冗余检测（多用于适配器中的链路层）</strong></p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><ul><li>最简单的方式：加一个<strong>奇偶校验位</strong>，使1的个数为偶数，接收方数一数1的个数是否为奇还是偶。如果1的个数为奇/偶说明？<br><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511203119.png"></li><li>使用<strong>二维奇偶校验</strong>，实际上是从横向和纵向判断1奇偶的个数，某个位置出错，可以定位错误位置，但是出现<strong>对偶校验</strong>是无法判断的。<br><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511204339.png"></li></ul><h3 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h3><p>如6-4中d比特数据作为k比特整数的序列处理，简单的校验和是将k比特相加，用该和作为差错检测比特（如因特网中的checksum此处不再赘述）</p><h3 id="循环冗余检测（CRC）"><a href="#循环冗余检测（CRC）" class="headerlink" title="循环冗余检测（CRC）"></a>循环冗余检测（CRC）</h3><p>也称为<strong>多项式编码</strong>。CRC运算采用<strong>模2算术</strong>，即<strong>加法不进位，减法不借位</strong>，实际上与<strong>异或</strong>运算相同。<br>首先明确几个概念：</p><ul><li>考虑d位的数据D</li><li>生成多项式：双方约定的r次方，r+1比特的模式，记为G</li><li>模2运算<br><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511204931.png"></li><li>位串的两种表示形式：位或者多项式</li><li>r个比特的冗余位附在D后，记为R<br>该检测的方法：发送方在D后附上r位冗余位，使得接收方除G（r+1位）能整除。注意到G是双方约定的，我们只需要<strong>找到R位冗余位</strong>。<br>此处关于R的推导略过<br><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511212040.png"></li></ul><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><h2 id="链路虚拟化"><a href="#链路虚拟化" class="headerlink" title="链路虚拟化"></a>链路虚拟化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第六章-链路层和局域网&quot;&gt;&lt;a href=&quot;#第六章-链路层和局域网&quot; class=&quot;headerlink&quot; title=&quot;第六章 链路层和局域网&quot;&gt;&lt;/a&gt;第六章 链路层和局域网&lt;/h1&gt;&lt;p&gt;本文基于中科大计算机网络自顶向下课程主要记录我在学习链路层和局域网过</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://gzz20020424.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://gzz20020424.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="链路层" scheme="http://gzz20020424.github.io/tags/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    <category term="局域网" scheme="http://gzz20020424.github.io/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="http://gzz20020424.github.io/2022/05/09/san-ci-wo-shou-he-si-ci-hui-shou/"/>
    <id>http://gzz20020424.github.io/2022/05/09/san-ci-wo-shou-he-si-ci-hui-shou/</id>
    <published>2022-05-09T09:02:54.000Z</published>
    <updated>2022-05-11T07:25:00.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP管理连接"><a href="#TCP管理连接" class="headerlink" title="TCP管理连接"></a>TCP管理连接</h1><p>首先我们知道TCP被称为<strong>面向连接的</strong>，因为一个进程向另一个进程发送数据前，两个进程需要先互相握手，即先发送某些预备报文段，例如序列号，确认号等后续将会提到。</p><h2 id="所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解："><a href="#所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：" class="headerlink" title="所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解："></a>所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：</h2><p><img src="https://raw.githubusercontent.com/gzz20020424/blog-img/main/20220511152426.png"></p><h3 id="以下是TCP建立连接的步骤：（同时我们会引入TCP状态的概念并以客户TCP经历的状态说明）"><a href="#以下是TCP建立连接的步骤：（同时我们会引入TCP状态的概念并以客户TCP经历的状态说明）" class="headerlink" title="以下是TCP建立连接的步骤：（同时我们会引入TCP状态的概念并以客户TCP经历的状态说明）"></a>以下是TCP建立连接的步骤：（同时我们会引入<strong>TCP状态</strong>的概念并以客户TCP经历的状态说明）</h3><ul><li><p>第一步：客户端原来处于<strong>CLOSE</strong>状态，客户端向服务器端发送一个特殊TCP报文段，不包含应用层数据，但是其中<strong>SYN比特被置为1</strong>，另外客户会随机选择一个<strong>初始序号（client_isn)<strong>，放在报文段的序号字段中，封装成IP数据报，为防止攻击，有许多有趣的研究初始化client_isn。第一步后，变成了</strong>SYN_SENT状态</strong>。</p></li><li><p>第二步：客户端的报文段到达后，服务器提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向客户TCP发送允许连接的报文段。该报文段首部有3个重要信息：</p></li></ul><p><strong>1.SYN比特被置为1;</strong><br><strong>2.确认号字段被置为client_isn + 1;</strong><br><strong>3.将服务器选择自己的server_isn放入序号字段中</strong></p><p>注意到该允许连接的报文段被称为<strong>SYN报文段</strong></p><ul><li>第三步：收到SYNACK报文段后，客户也要分配缓存和变量，并再向服务器端发送另外一个报文段，将server_isn + 1放置到确认字段中。连接已经建立，客户端变为<strong>ESTABLISHED</strong>状态<strong>SYN字段被置为0</strong>。</li></ul><h3 id="注意到客户端和服务器建立连接的过程之间发送了3个分组，所以称为-三次连接。以下我们探讨一下为什么要进行三次连接，而不是两次？四次？（实际场景举例）这里我学习了-小林coding-中的知识"><a href="#注意到客户端和服务器建立连接的过程之间发送了3个分组，所以称为-三次连接。以下我们探讨一下为什么要进行三次连接，而不是两次？四次？（实际场景举例）这里我学习了-小林coding-中的知识" class="headerlink" title="注意到客户端和服务器建立连接的过程之间发送了3个分组，所以称为 三次连接。以下我们探讨一下为什么要进行三次连接，而不是两次？四次？（实际场景举例）这里我学习了 小林coding 中的知识"></a>注意到客户端和服务器建立连接的过程之间发送了3个分组，所以称为 <em>三次连接</em>。以下我们探讨一下为什么要进行三次连接，而不是两次？四次？（实际场景举例）这里我学习了 <em>小林coding</em> 中的知识</h3><ul><li><p><strong>三次握手才能阻止重复历史连接的初始化；</strong><br>思考一个这样的场景：<br>客户端向服务器发送seq num = 90的请求， 由于<strong>网络阻塞</strong>，导致<strong>超时重发</strong>或者<strong>快速重传</strong>，新的seq_num = 100。这时旧的报文到达，服务器分配缓存，变量，将SYN = 300,ACK = 91发送给客户端。这时客户端发送<strong>RST(连接中止)<strong>，直到新的报文到达，SYN = 400,ACK = 101。客户端再发送ACK = 401。这个过程中</strong>分配内存和变量造成很大开销</strong>。</p></li><li><p><strong>三次握手才可以同步双方初始序列号</strong>；<br>需要返回ACK，一来一回才能确保双方序列号被可靠同步。</p></li><li><p><strong>三次握手才可以避免资源浪费</strong>，仍然考虑<strong>网络阻塞</strong>的问题，多次发送SYN，则会建立<strong>多个冗余的无效连接</strong>，造成资源浪费。</p></li><li><p>四次握手也能实现可靠连接，但是在<strong>server确认ACK报文中可以把自己的序列号一起放入</strong>，所以进行三次握手。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP管理连接&quot;&gt;&lt;a href=&quot;#TCP管理连接&quot; class=&quot;headerlink&quot; title=&quot;TCP管理连接&quot;&gt;&lt;/a&gt;TCP管理连接&lt;/h1&gt;&lt;p&gt;首先我们知道TCP被称为&lt;strong&gt;面向连接的&lt;/strong&gt;，因为一个进程向另一个进程发送数</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://gzz20020424.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP连接" scheme="http://gzz20020424.github.io/tags/TCP%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="计算机网络" scheme="http://gzz20020424.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="三次握手四次挥手" scheme="http://gzz20020424.github.io/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://gzz20020424.github.io/2022/03/03/hello-world/"/>
    <id>http://gzz20020424.github.io/2022/03/03/hello-world/</id>
    <published>2022-03-03T00:58:55.815Z</published>
    <updated>2022-03-03T00:23:55.568Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《C++ Primer》函数总结（部分）</title>
    <link href="http://gzz20020424.github.io/2022/02/26/test/"/>
    <id>http://gzz20020424.github.io/2022/02/26/test/</id>
    <published>2022-02-26T13:09:46.000Z</published>
    <updated>2022-05-10T15:28:55.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《C-Primer》函数总结（部分）"><a href="#《C-Primer》函数总结（部分）" class="headerlink" title="《C++ Primer》函数总结（部分）"></a>《C++ Primer》函数总结（部分）</h1><p>简单地说，<strong>函数是命了名的计算单元</strong>，也就是一个代码块：调用了函数就可以执行相应的代码块。在这篇笔记里，我不打算详细的介绍很多基本概念，相反地，我会更加关注于一些稍微进阶一点的知识以及如何避免出现问题的方法。</p><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><h3 id="调用函数的过程"><a href="#调用函数的过程" class="headerlink" title="调用函数的过程"></a>调用函数的过程</h3><p>首先，函数的调用会完成两项工作：1. 用实参初始化函数对应的形参；2. 将控制权转移给被调函数。主调函数的执行被中断，被调函数开始执行。当遇到一条 return 语句的时候函数结束执行过程。</p><h3 id="没有规定实参的求值顺序"><a href="#没有规定实参的求值顺序" class="headerlink" title="没有规定实参的求值顺序"></a>没有规定实参的求值顺序</h3><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。也就是说实参和形参存在对应关系，但是需要注意的是：<strong>没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值。</strong></p><h3 id="函数的返回类型"><a href="#函数的返回类型" class="headerlink" title="函数的返回类型"></a>函数的返回类型</h3><p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。（后面会讲到这个内容）。</p><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>首先理解<strong>生命周期</strong>的概念：<strong>程序执行过程中该对象存在的一段时间</strong>。</p><p>各种变量的生命周期？</p><ul><li>在所有函数体之外定义的变量存在于程序的整个执行过程中。那么这类对象在程序启动时创建，直到程序结束时才会销毁。</li><li>那对于局部变量呢？<ul><li>对于普通局部变量对应的对象来说：当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾销毁。（这种对象也称为<strong>自动对象</strong>）</li><li>而对于<strong>局部静态对象</strong>：它在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止时才销毁。</li></ul></li></ul><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。</p><h3 id="传值调用与传引用调用"><a href="#传值调用与传引用调用" class="headerlink" title="传值调用与传引用调用"></a>传值调用与传引用调用</h3><ul><li>传值调用：初始值拷贝给形参</li><li>传引用调用：引用形参绑定初始化它的对象</li></ul><h3 id="使用引用避免拷贝"><a href="#使用引用避免拷贝" class="headerlink" title="使用引用避免拷贝"></a>使用引用避免拷贝</h3><p>拷贝大的类类型或者容器对象比较低效，甚至有的类型（包括 IO 类型在内）根本就不支持拷贝操作（比如没有拷贝构造函数或者拷贝赋值运算符的类类型）。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。<br>同时，<strong>当函数无须修改引用参数的值时，最好使用常量引用</strong>。</p><h3 id="const-形参和实参"><a href="#const-形参和实参" class="headerlink" title="const 形参和实参"></a>const 形参和实参</h3><p><strong>当用实参初始化 const 形参时会忽略掉顶层 const</strong> 。也就是说，传给它常量对象还是非常量对象都是可以的，那么就会出现问题：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fcn</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 错误：重复定义，二义性调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h4><p>使用引用而不是常量引用会极大地限制函数所能接受的实参类型：例如不能把 const 对象、字面值或者需要类型转换的对象传递给普通的引用形参。<br><strong>如果函数无须改变引用形参的值，最好将其声明为常量引用。</strong></p><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>简单地列举使用数组形参的几种方式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用标准库提供的 begin() 和 end()</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>beg<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用方法： print(begin(arr), end(arr));</span><span class="token comment">// 数组引用形参 &amp;arr两端的括号必不可少</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 如何传递多维数组？</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> matrix<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>matrix<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同样 *matrix 两端的括号必不可少</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="返回类型和-return-语句"><a href="#返回类型和-return-语句" class="headerlink" title="返回类型和 return 语句"></a>返回类型和 return 语句</h2><p>首先关注的一个问题是<strong>值是如何被返回的？</strong>其实答案不复杂：返回的值初始化一个临时变量，该临时变量就是函数调用的结果；如果返回的是引用类型，那么返回的引用就仅仅是它所引用对象的一个别名。<br>那么这也可以告诉我们：<strong>不要返回局部变量的引用或者指针</strong>，因为函数完成后，局部变量所占用的内存也就随之被释放掉了。</p><p>还有一点值得关注的就是：<strong>引用返回左值</strong>。那我们也就可以“骚操作”一下：为返回类型是非常量引用的函数的结果赋值。</p><h3 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h3><p>C++11 新标准规定，函数可以返回花括号包围的值的列表。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><h4 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h4><p>使用类型别名是最简单的方法：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">int</span> arrT<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// arrT 是一个类型别名，表示含有10个整数的数组</span><span class="token keyword">using</span> arrT <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// C++11 新标准</span>arrT <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// func 返回一个数组指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="啥也不用，就硬刚"><a href="#啥也不用，就硬刚" class="headerlink" title="啥也不用，就硬刚"></a>啥也不用，就硬刚</h4><p>真的勇士：<code>int (*func(int i))[10];</code></p><h4 id="使用尾置返回类型"><a href="#使用尾置返回类型" class="headerlink" title="使用尾置返回类型"></a>使用尾置返回类型</h4><p>C++11 新标准：`auto func(int i) -&gt; int(*)[10];</p><h4 id="使用-decltype"><a href="#使用-decltype" class="headerlink" title="使用 decltype"></a>使用 decltype</h4><p>有一种情况是，如果我们知道函数返回的数组指针将会指向哪个数组，就可以使用 decltype 关键字声明返回类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> odd<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> even<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>odd<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">&amp;</span>odd <span class="token operator">:</span> <span class="token operator">&amp;</span>even<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有一个地方需要注意：<strong>decltype 并不会把数组类型转换为对应的指针，所以 decltype 在这里的结果是一个数组</strong>，这也就意味着我们需要在函数声明前加多一个 * 符号。</p><h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>这里不用多说了，主要就是注意一个地方：<strong>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</strong>。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>为什么会出现内联函数？在大多数机器上，一个函数调用其实包含着一系列的工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝形参；程序转向一个新的地方执行。<br>对于规模较小的函数来说，这一系列操作未免也太浪费性能了，于是就出现了内联函数。<br><strong>内联函数可以避免函数调用的开销</strong>，把函数指定为内敛(<code>inline</code>)，通常就意味着在每个调用点上“内联地”展开。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 如果像这样调用：</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">shorterString</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token comment">// 那么在编译时会类似这样展开：</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是：<strong>内联说明只是向编译器提供的一个建议，是否内联最终还是由编译器来决定</strong>。<br>建议：<strong>内联机制用于优化规模较小、流程直接、调用频繁的函数</strong>。</p><h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h3><p>constexpr 函数是指能够作用于常量表达式的函数，它有几点要求：</p><ul><li>函数的返回类型以及所有的形参都得是字面值类型</li><li>函数体中必须有且只有一条 return 语句<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">constexpr</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>作用机理：编译器会将对 constexpr 函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。</p><p>值得注意的是，<strong>constexpr 函数不一定返回常量表达式</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> size_t <span class="token function">scale</span><span class="token punctuation">(</span>size_t cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">new_sz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> cnt<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 正确：scale(2)是常量表达式</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment">// i 不是常量表达式</span><span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token function">scale</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 错误：scale(i)不是常量表达式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子，也就是说当给 scale() 传入一个常量表达式时，它返回一个常量表达式，否则它会返回一个非常量表达式。</p><p>最后的建议：<strong>把内联函数和 constexpr 函数放在头文件内</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《C-Primer》函数总结（部分）&quot;&gt;&lt;a href=&quot;#《C-Primer》函数总结（部分）&quot; class=&quot;headerlink&quot; title=&quot;《C++ Primer》函数总结（部分）&quot;&gt;&lt;/a&gt;《C++ Primer》函数总结（部分）&lt;/h1&gt;&lt;p&gt;简单</summary>
      
    
    
    
    <category term="C++" scheme="http://gzz20020424.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://gzz20020424.github.io/tags/C/"/>
    
    <category term="《C++ Primer》" scheme="http://gzz20020424.github.io/tags/%E3%80%8AC-Primer%E3%80%8B/"/>
    
  </entry>
  
</feed>
